@model BuckScience.Web.ViewModels.Properties.PropertyFeatureVm
@{
    ViewData["Title"] = $"Edit {Model.Name} - Feature";
}

<div class="feature-edit" style="max-width: 350px;">
    <!-- Header with Cancel Button -->
    <div class="d-flex justify-content-between align-items-center mb-3">
        <h2 class="sidebar-title">Edit Feature</h2>
        <button type="button" class="btn btn-custom-cancel btn-sm" onclick="cancelFeatureEdit()">
            <i class="fas fa-times"></i> Cancel
        </button>
    </div>
    <hr class="sidebar-title-separator mb-4" />

    <!-- Instructions Alert -->
    <div class="alert alert-success mb-4" role="alert">
        <i class="fas fa-edit me-2"></i>
        <strong>Drag</strong> to modify shape. Make changes and save.
    </div>

    <!-- Edit Form -->
    <form id="featureEditForm">
        <div class="mb-3">
            <label for="editFeatureName" class="form-label">Feature Name</label>
            <input type="text" class="form-control" id="editFeatureName" 
                   placeholder="Custom name (optional)" 
                   maxlength="100">
            <small class="text-muted">Leave blank for default type name</small>
        </div>

        <div class="mb-3">
            <label for="editFeatureType" class="form-label">Feature Type</label>
            <select class="form-select" id="editFeatureType" required>
                <!-- Options will be populated by JavaScript -->
            </select>
        </div>

        <div class="mb-3" style="display: none;">
            <label class="form-label">Geometry Type</label>
            <div class="p-2 border rounded bg-light">
                <small class="text-muted" id="geometryTypeDisplay"></small>
            </div>
        </div>

        <div class="mb-4">
            <label for="editFeatureNotes" class="form-label">Notes</label>
            <textarea class="form-control" id="editFeatureNotes" rows="3" 
                      placeholder="Add notes..."></textarea>
        </div>
    </form>

    <!-- Action Buttons -->
    <div class="mt-4 d-flex gap-2">
        <button type="button" class="btn btn-outline-secondary" onclick="cancelFeatureEdit()">
            Cancel
        </button>
        <button type="button" class="btn btn-custom-primary" onclick="saveFeatureEdit(@Model.Id)">
            <i class="fas fa-save me-1"></i>Save Changes
        </button>
    </div>
</div>

@section Scripts {
    <script>
        function initializeFeatureEdit() {
            console.log('=== INITIALIZING FEATURE EDIT ===');
            console.log('Initializing feature edit for ID:', @Model.Id);
            console.log('Model data available:', {
                id: @Model.Id,
                name: '@(Html.Raw(Model.Name?.Replace("'", "\\'").Replace("\"", "\\\"") ?? ""))',
                type: @((int)Model.Type),
                notes: '@(Html.Raw(Model.Notes?.Replace("'", "\\'").Replace("\"", "\\\"") ?? ""))',
                geometryWkt: '@(Model.GeometryWkt ?? "Unknown")'
            });
            
            // Focus on the feature being edited
            if (window.App && window.App.focusPropertyFeature) {
                window.App.focusPropertyFeature(@Model.Id);
            }

            let featureData = null;
            
            // Try to get feature data from the map source first (most current data)
            const m = window.App && window.App.map ? window.App.map() : null;
            if (m) {
                const source = m.getSource('property-features');
                if (source && source._data && source._data.features) {
                    const targetFeature = source._data.features.find(f => f.properties.id === @Model.Id);
                    if (targetFeature) {
                        featureData = targetFeature;
                        console.log('Found feature data from map source:', featureData);
                    }
                }
            }

            // Fallback: Use server data if map data not available
            if (!featureData) {
                featureData = {
                    properties: {
                        id: @Model.Id,
                        name: '@(Html.Raw(Model.Name?.Replace("'", "\\'").Replace("\"", "\\\"") ?? ""))',
                        classificationType: @((int)Model.Type),
                        notes: '@(Html.Raw(Model.Notes?.Replace("'", "\\'").Replace("\"", "\\\"") ?? ""))'
                    },
                    geometry: {
                        type: '@(Model.GeometryWkt?.Split('(')[0] ?? "Unknown")'
                    }
                };
                console.log('Using server data as fallback:', featureData);
            }

            // Store feature data for editing
            window.App._editingFeature = featureData;
            window.App._editingFeatureId = @Model.Id;

            // Populate form fields with feature data
            const props = featureData.properties;
            console.log('Populating form with props:', props);
            
            // Populate feature name (use custom name if provided, otherwise empty)
            const nameInput = document.getElementById('editFeatureName');
            if (nameInput) {
                nameInput.value = props.name || '';
                console.log('Set feature name:', nameInput.value);
            } else {
                console.error('editFeatureName input not found');
            }

            // Populate feature type options and select current type
            const selectElement = document.getElementById('editFeatureType');
            if (selectElement && window.FeatureUtils) {
                selectElement.innerHTML = window.FeatureUtils.generateFeatureOptionsHtml(props.classificationType);
                console.log('Populated feature type options, selected:', props.classificationType);
            } else if (selectElement) {
                // Fallback if FeatureUtils not available
                selectElement.innerHTML = `<option value="${props.classificationType}" selected>Feature Type ${props.classificationType}</option>`;
                console.warn('FeatureUtils not available, using fallback option');
            } else {
                console.error('editFeatureType select not found');
            }

            // Populate notes
            const notesTextarea = document.getElementById('editFeatureNotes');
            if (notesTextarea) {
                notesTextarea.value = props.notes || '';
                console.log('Set feature notes:', notesTextarea.value);
            } else {
                console.error('editFeatureNotes textarea not found');
            }

            // Update geometry type display
            const geometryDisplay = document.getElementById('geometryTypeDisplay');
            if (geometryDisplay && featureData.geometry) {
                geometryDisplay.textContent = featureData.geometry.type;
            }

            // Enable geometry editing for the feature
            setTimeout(() => {
                if (typeof window.enableGeometryEditing === 'function') {
                    window.enableGeometryEditing(featureData);
                    console.log('Enabled geometry editing');
                }
            }, 500);
            
            console.log('=== FEATURE EDIT INITIALIZATION COMPLETE ===');
        }

        // Initialize when DOM is ready
        document.addEventListener('DOMContentLoaded', function() {
            console.log('DOMContentLoaded - calling initializeFeatureEdit');
            initializeFeatureEdit();
        });

        // Handle sidebar load events - re-initialize when loaded in sidebar
        document.addEventListener('sidebar:loaded', function(event) {
            console.log('sidebar:loaded event received:', event.detail);
            if (event.detail && event.detail.url && event.detail.url.includes('/features/@Model.Id/edit')) {
                console.log('Feature edit loaded in sidebar, re-initializing...');
                setTimeout(function() {
                    console.log('Re-initializing feature edit after sidebar load delay');
                    initializeFeatureEdit();
                }, 300);
            }
        });

        // Also initialize immediately if this script runs after DOM is ready
        if (document.readyState === 'loading') {
            // DOM not ready yet, wait for DOMContentLoaded
            console.log('DOM still loading, waiting for DOMContentLoaded');
        } else {
            // DOM is ready, initialize immediately
            console.log('DOM already ready, initializing immediately');
            setTimeout(function() {
                initializeFeatureEdit();
            }, 100);
        }
    </script>
}