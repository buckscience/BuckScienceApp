@model BuckScience.Web.ViewModels.Properties.PropertyFeatureVm
@{
    ViewData["Title"] = $"Edit {Model.Name} - Feature";
}

<div class="feature-edit" style="max-width: 350px;">
    <!-- Header with Cancel Button -->
    <div class="d-flex justify-content-between align-items-center mb-3">
        <h2 class="sidebar-title">Edit Feature</h2>
        <button type="button" class="btn btn-custom-cancel btn-sm" onclick="cancelFeatureEdit()">
            <i class="fas fa-times"></i> Cancel
        </button>
    </div>
    <hr class="sidebar-title-separator mb-4" />

    <!-- Instructions Alert -->
    <div class="alert alert-success mb-4" role="alert">
        <i class="fas fa-edit me-2"></i>
        <strong>Drag</strong> to modify shape. Make changes and save.
    </div>

    <!-- Edit Form -->
    <form id="featureEditForm">
        <div class="mb-3">
            <label for="editFeatureName" class="form-label">Feature Name</label>
            <input type="text" class="form-control" id="editFeatureName" 
                   placeholder="Custom name (optional)" 
                   value="@Model?.Name"
                   maxlength="100">
            <small class="text-muted">Leave blank for default type name</small>
        </div>

        <div class="mb-3">
            <label for="editFeatureType" class="form-label">Feature Type</label>
            <select class="form-select" id="editFeatureType" required>
                @if (ViewBag.FeatureTypeOptions != null)
                {
                    @foreach (var option in ViewBag.FeatureTypeOptions)
                    {
                        <option value="@option.Value" selected="@option.Selected" disabled="@option.Disabled">@option.Text</option>
                    }
                }
                else
                {
                    <option value="">Loading feature types...</option>
                    @if (Model?.Type != null)
                    {
                        <option value="@((int)Model.Type)" selected>@Model.TypeName</option>
                    }
                }
            </select>
        </div>

        <div class="mb-3" style="display: none;">
            <label class="form-label">Geometry Type</label>
            <div class="p-2 border rounded bg-light">
                <small class="text-muted" id="geometryTypeDisplay"></small>
            </div>
        </div>

        <div class="mb-4">
            <label for="editFeatureNotes" class="form-label">Notes</label>
            <textarea class="form-control" id="editFeatureNotes" rows="3" 
                      placeholder="Add notes...">@Model?.Notes</textarea>
        </div>
    </form>

    <!-- Action Buttons -->
    <div class="mt-4 d-flex gap-2">
        <button type="button" class="btn btn-outline-secondary" onclick="cancelFeatureEdit()">
            Cancel
        </button>
        <button type="button" class="btn btn-custom-primary" onclick="saveFeatureEdit(@Model.Id)">
            <i class="fas fa-save me-1"></i>Save Changes
        </button>
    </div>
</div>

@section Scripts {
    <script>
        const FEATURE_ID = @Model.Id;
        
        async function loadFeatureData() {
            try {
                console.log('=== LOADING FEATURE DATA ===');
                console.log('Loading feature data for ID:', FEATURE_ID);
                const response = await fetch(`/features/${FEATURE_ID}`);
                
                console.log('API response status:', response.status);
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }
                
                const featureData = await response.json();
                console.log('Loaded feature data from API:', featureData);
                return featureData;
            } catch (error) {
                console.error('Error loading feature data:', error);
                return null;
            }
        }

        function populateForm(featureData) {
            console.log('=== POPULATING FORM ===');
            console.log('Feature data:', featureData);
            
            // Update geometry type display
            const geometryDisplay = document.getElementById('geometryTypeDisplay');
            if (geometryDisplay && featureData) {
                const geometryWkt = featureData.geometryWkt || featureData.GeometryWkt || '';
                const geometryType = geometryWkt.split('(')[0] || 'Unknown';
                geometryDisplay.textContent = geometryType;
                console.log('Updated geometry type display:', geometryType);
            }
        }

        async function initializeFeatureEdit() {
            console.log('=== INITIALIZING FEATURE EDIT ===');
            console.log('Initializing feature edit for ID:', FEATURE_ID);
            
            // Focus on the feature being edited
            if (window.App && window.App.focusPropertyFeature) {
                window.App.focusPropertyFeature(FEATURE_ID);
                console.log('Focused on property feature');
            }

            // Load fresh feature data from API
            const featureData = await loadFeatureData();
            if (!featureData) {
                console.error('Failed to load feature data');
                return;
            }

            // Store feature data for editing
            if (window.App) {
                window.App._editingFeature = featureData;
                window.App._editingFeatureId = FEATURE_ID;
                console.log('Stored editing feature data');
            }

            // Populate form with loaded data
            populateForm(featureData);

            // Enable geometry editing for the feature
            setTimeout(() => {
                if (typeof window.enableGeometryEditing === 'function') {
                    console.log('Enabling geometry editing...');
                    const normalizedFeature = {
                        ...featureData,
                        geometryWkt: featureData.geometryWkt || featureData.GeometryWkt
                    };
                    window.enableGeometryEditing(normalizedFeature);
                    console.log('Enabled geometry editing for feature:', normalizedFeature);
                } else {
                    console.warn('enableGeometryEditing function not available');
                }
            }, 500);
        }

        // Initialize when DOM is ready
        function startInitialization() {
            console.log('=== STARTING INITIALIZATION ===');
            // Wait for elements to be available
            const waitForElements = () => {
                const typeSelect = document.getElementById('editFeatureType');
                
                if (typeSelect) {
                    console.log('Feature type select found, starting initialization');
                    initializeFeatureEdit();
                } else {
                    console.log('Waiting for feature type select...');
                    setTimeout(waitForElements, 50);
                }
            };
            
            waitForElements();
        }

        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', startInitialization);
        } else {
            setTimeout(startInitialization, 10);
        }

        // Handle sidebar load events
        document.addEventListener('sidebar:loaded', function(event) {
            console.log('Sidebar loaded event:', event.detail);
            if (event.detail && event.detail.url && event.detail.url.includes(`/features/${FEATURE_ID}/edit`)) {
                console.log('Sidebar loaded for feature edit, reinitializing...');
                setTimeout(startInitialization, 100);
            }
        });
    </script>
}