@model BuckScience.Web.ViewModels.Properties.PropertyFeatureEditVm
@{
    ViewData["Title"] = $"Edit Feature";
}

<div class="feature-edit" style="max-width: 350px;">
    <!-- Header with Cancel Button -->
    <div class="d-flex justify-content-between align-items-center mb-3">
        <h2 class="sidebar-title">Edit Feature</h2>
        <button type="button" class="btn btn-custom-cancel btn-sm" onclick="cancelFeatureEdit()">
            <i class="fas fa-times"></i> Cancel
        </button>
    </div>
    <hr class="sidebar-title-separator mb-4" />

    <!-- Instructions Alert -->
    <div class="alert alert-success mb-4" role="alert">
        <i class="fas fa-edit me-2"></i>
        <strong>Drag</strong> to modify shape. Make changes and save.
    </div>

    <!-- Edit Form -->
    <form asp-action="FeatureEdit" method="post" data-ajax="true">
        @Html.AntiForgeryToken()
        <input type="hidden" asp-for="Id" />
        <input type="hidden" asp-for="GeometryWkt" />

        <div asp-validation-summary="ModelOnly" class="text-danger mb-3"></div>

        <div class="mb-3">
            <label asp-for="Name" class="form-label">Feature Name</label>
            <input asp-for="Name" class="form-control" 
                   placeholder="Custom name (optional)" 
                   maxlength="100" />
            <span asp-validation-for="Name" class="text-danger"></span>
            <small class="text-muted">Leave blank for default type name</small>
        </div>

        <div class="mb-3">
            <label asp-for="Type" class="form-label">Feature Type</label>
            <select asp-for="Type" class="form-select" id="editFeatureType" required>
                <option value="">Loading feature types...</option>
            </select>
            <span asp-validation-for="Type" class="text-danger"></span>
        </div>

        <div class="mb-3" style="display: none;">
            <label class="form-label">Geometry Type</label>
            <div class="p-2 border rounded bg-light">
                <small class="text-muted" id="geometryTypeDisplay"></small>
            </div>
        </div>

        <div class="mb-4">
            <label asp-for="Notes" class="form-label">Notes</label>
            <textarea asp-for="Notes" class="form-control" rows="3" 
                      placeholder="Add notes..."></textarea>
            <span asp-validation-for="Notes" class="text-danger"></span>
        </div>

        <!-- Action Buttons -->
        <div class="mt-4 d-flex gap-2">
            <button type="button" class="btn btn-outline-secondary" onclick="cancelFeatureEdit()">
                Cancel
            </button>
            <button type="submit" class="btn btn-custom-primary">
                <i class="fas fa-save me-1"></i>Save Changes
            </button>
        </div>
    </form>
</div>

@section Scripts {
    <partial name="_ValidationScriptsPartial" />
    
    <script>
        const FEATURE_ID = @Model.Id;
        
        async function loadFeatureData() {
            try {
                console.log('Loading feature data for ID:', FEATURE_ID);
                const response = await fetch(`/features/${FEATURE_ID}`);
                
                if (!response.ok) {
                    throw new Error(`Failed to load feature data: ${response.status}`);
                }
                
                const featureData = await response.json();
                console.log('Loaded feature data from API:', featureData);
                return featureData;
            } catch (error) {
                console.error('Error loading feature data:', error);
                return null;
            }
        }

        function populateForm(featureData) {
            // Update geometry WKT in hidden field (required for editing)
            const geometryInput = document.querySelector('input[name="GeometryWkt"]');
            if (geometryInput && featureData) {
                const geometryWkt = featureData.geometryWkt || featureData.GeometryWkt || '';
                geometryInput.value = geometryWkt;
                console.log('Updated geometry WKT in form');
            }
            
            // Populate feature type options
            const typeSelect = document.getElementById('editFeatureType');
            if (typeSelect && window.FeatureUtils) {
                const currentType = featureData.classificationType || featureData.ClassificationType;
                typeSelect.innerHTML = window.FeatureUtils.generateFeatureOptionsHtml(currentType);
                console.log('Populated feature type options, selected:', currentType);
            }

            // Update geometry type display
            const geometryDisplay = document.getElementById('geometryTypeDisplay');
            if (geometryDisplay && featureData) {
                const geometryWkt = featureData.geometryWkt || featureData.GeometryWkt || '';
                const geometryType = geometryWkt.split('(')[0] || 'Unknown';
                geometryDisplay.textContent = geometryType;
            }
        }

        async function initializeFeatureEdit() {
            console.log('Initializing feature edit for ID:', FEATURE_ID);
            
            // Focus on the feature being edited
            if (window.App && window.App.focusPropertyFeature) {
                window.App.focusPropertyFeature(FEATURE_ID);
            }

            // Load fresh feature data from API
            const featureData = await loadFeatureData();
            if (!featureData) {
                console.error('Failed to load feature data');
                return;
            }

            // Store feature data for editing
            if (window.App) {
                window.App._editingFeature = featureData;
                window.App._editingFeatureId = FEATURE_ID;
            }

            // Populate form with loaded data
            populateForm(featureData);

            // Enable geometry editing for the feature
            setTimeout(() => {
                if (typeof window.enableGeometryEditing === 'function') {
                    const normalizedFeature = {
                        ...featureData,
                        geometryWkt: featureData.geometryWkt || featureData.GeometryWkt
                    };
                    window.enableGeometryEditing(normalizedFeature);
                    console.log('Enabled geometry editing');
                }
            }, 500);
        }

        // Initialize when DOM is ready
        function startInitialization() {
            // Wait for elements AND dependencies to be available
            const waitForElementsAndDependencies = () => {
                const typeSelect = document.getElementById('editFeatureType');
                const featureUtilsAvailable = !!window.FeatureUtils;
                
                if (typeSelect && featureUtilsAvailable) {
                    initializeFeatureEdit();
                } else {
                    setTimeout(waitForElementsAndDependencies, 50);
                }
            };
            
            waitForElementsAndDependencies();
        }

        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', startInitialization);
        } else {
            setTimeout(startInitialization, 10);
        }

        // Handle sidebar load events
        document.addEventListener('sidebar:loaded', function(event) {
            if (event.detail && event.detail.url && event.detail.url.includes(`/features/${FEATURE_ID}/edit`)) {
                setTimeout(startInitialization, 100);
            }
        });

        // Update geometry WKT when geometry changes (called by map editing functions)
        window.updateFeatureGeometry = function(newGeometryWkt) {
            const geometryInput = document.querySelector('input[name="GeometryWkt"]');
            if (geometryInput) {
                geometryInput.value = newGeometryWkt;
                console.log('Updated geometry WKT:', newGeometryWkt.substring(0, 50) + '...');
            }
        };
    </script>
}