@model BuckScience.Web.ViewModels.BuckTrax.BuckTraxIndexVm
@{
    ViewData["Title"] = "BuckTrax - Movement Prediction";
}

<div class="container-fluid h-100 d-flex flex-column">
    <div class="d-flex flex-column h-100">
        <div class="d-flex align-items-center">
            <i class="fas fa-route text-primary me-3" style="font-size: 1.5rem;"></i>
            <h2 class="sidebar-title mb-0">BuckTrax</h2>
        </div>
        <p class="text-muted mb-3">Predict deer movement patterns based on sighting history and property features.</p>
        <hr class="sidebar-title-separator" />

        <div class="flex-grow-1 d-flex flex-column">
            <!-- Property Selection -->
            <div class="mb-3">
                <label class="form-label fw-bold">
                    <i class="fas fa-map-marked-alt me-2"></i>Select Property
                </label>
                @if (Model.Properties.Any())
                {
                    <select id="property-selector" class="form-select">
                        <option value="">Choose a property...</option>
                        @foreach (var property in Model.Properties)
                        {
                            <option value="@property.Id">@property.Name</option>
                        }
                    </select>
                }
                else
                {
                    <div class="alert alert-success" style="background-color: #f0f8f0; border-color: #527A52; color: #2d3748;">
                        <i class="fas fa-info-circle me-2"></i>
                        No properties found. <a href="/properties">Create a property</a> to get started.
                    </div>
                }
            </div>

            <!-- Profile Selection -->
            <div class="mb-3" id="profile-section" style="display: none;">
                <label class="form-label fw-bold">
                    <i class="fas fa-deer me-2"></i>Select Profile
                </label>
                <div id="profile-selector">
                    <!-- Profiles will be loaded dynamically -->
                </div>
            </div>

            <!-- Prediction Controls -->
            <div class="mb-3" id="prediction-section" style="display: none;">
                <button id="run-prediction" class="btn btn-custom-primary w-100" disabled>
                    <i class="fas fa-play me-2"></i>
                    Run BuckTrax Prediction
                </button>
                <div id="prediction-loading" class="text-center mt-3" style="display: none;">
                    <div class="spinner-border" style="color: #527A52;" role="status">
                        <span class="visually-hidden">Loading...</span>
                    </div>
                    <p class="mt-2 text-muted">Analyzing movement patterns...</p>
                </div>
            </div>

            <!-- Results Section -->
            <div class="flex-grow-1" id="results-section" style="display: none;">
                <!-- Limited Data Warning -->
                <div id="limited-data-warning" class="alert alert-warning" style="display: none;">
                    <i class="fas fa-exclamation-triangle me-2"></i>
                    <span id="limited-data-message"></span>
                </div>

                <!-- Map Layer Controls -->
                <div class="mb-3">
                    <label class="form-label fw-bold">
                        <i class="fas fa-layer-group me-2"></i>Map Layers
                    </label>
                    <div class="form-check form-switch">
                        <input class="form-check-input" type="checkbox" id="show-property-features" checked>
                        <label class="form-check-label" for="show-property-features">
                            Property Features
                        </label>
                    </div>
                    <div class="form-check form-switch">
                        <input class="form-check-input" type="checkbox" id="show-prediction-zones" checked>
                        <label class="form-check-label" for="show-prediction-zones">
                            Prediction Zones
                        </label>
                    </div>
                    <div class="form-check form-switch">
                        <input class="form-check-input" type="checkbox" id="show-movement-corridors" checked>
                        <label class="form-check-label" for="show-movement-corridors">
                            Movement Corridors
                        </label>
                    </div>
                    <div class="form-check form-switch">
                        <input class="form-check-input" type="checkbox" id="show-cameras" checked>
                        <label class="form-check-label" for="show-cameras">
                            Camera Locations
                        </label>
                    </div>
                </div>

                <!-- Summary Stats -->
                <div class="row g-2 mb-3" id="summary-stats">
                    <div class="col-4">
                        <div class="card text-center">
                            <div class="card-body px-2 py-2">
                                <div class="h6 text-primary mb-0" id="total-sightings">0</div>
                                <small class="text-muted">Sightings</small>
                            </div>
                        </div>
                    </div>
                    <div class="col-4">
                        <div class="card text-center">
                            <div class="card-body px-2 py-2">
                                <div class="h6 text-success mb-0" id="total-transitions">0</div>
                                <small class="text-muted">Transitions</small>
                            </div>
                        </div>
                    </div>
                    <div class="col-4">
                        <div class="card text-center">
                            <div class="card-body px-2 py-2">
                                <div class="h6 text-info mb-0" id="active-periods">0</div>
                                <small class="text-muted">Periods</small>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Time Segment Tabs -->
                <div class="mb-3">
                    <label class="form-label fw-bold">
                        <i class="fas fa-clock me-2"></i>Time Periods
                    </label>
                    <ul class="nav nav-pills nav-fill" id="time-segment-tabs" role="tablist">
                        <!-- Time segments will be loaded dynamically -->
                    </ul>
                </div>

                <!-- Active Time Segment Details -->
                <div class="flex-grow-1">
                    <div id="time-segment-content">
                        <!-- Time segment details will be loaded dynamically -->
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

@section Scripts {
    <script>
        let selectedPropertyId = null;
        let selectedProfileId = null;
        let currentPredictions = null;
        let currentPropertyFeatures = null;
        let bucktraxLayers = {
            corridors: [],
            zones: [],
            features: [],
            sources: []
        };

        $(document).ready(function() {
            initializeBuckTrax();
        });

        function initializeBuckTrax() {
            // Property selection handler
            $('#property-selector').on('change', function() {
                selectedPropertyId = $(this).val();
                if (selectedPropertyId) {
                    // Clear existing property features before loading new ones
                    clearFeatureLayers();
                    
                    loadPropertyProfiles(selectedPropertyId);
                    loadPropertyFeatures(selectedPropertyId);
                    
                    // Trigger map layer update - same as Properties Details
                    if (window.App && window.App.triggerMapLayerUpdate) {
                        window.App.triggerMapLayerUpdate({ propertyId: selectedPropertyId });
                    }
                    
                    showProfileSection();
                } else {
                    hideProfileSection();
                    clearAllLayers(); // Clear everything when no property selected
                }
            });

            // Prediction button handler
            $('#run-prediction').on('click', function() {
                if (selectedProfileId) {
                    runMovementPrediction(selectedProfileId);
                }
            });

            // Layer visibility handlers
            $('#show-property-features, #show-prediction-zones, #show-movement-corridors, #show-cameras').on('change', function() {
                updateLayerVisibility();
            });

            // Ensure checkboxes are checked by default for better UX
            $('#show-property-features').prop('checked', true);
            $('#show-prediction-zones').prop('checked', true);
            $('#show-movement-corridors').prop('checked', true);
            $('#show-cameras').prop('checked', true);
        }

        function loadPropertyFeatures(propertyId) {
            // Use the EXACT same approach as Properties Details view
            if (window.App && window.App.initializePropertyFeatures) {
                console.log('Using properties.js initializePropertyFeatures for property:', propertyId);
                window.App.initializePropertyFeatures(propertyId);
                
                // Track the feature layer IDs created by initializePropertyFeatures for visibility control
                bucktraxLayers.features = ['property-features-fill', 'property-features-line', 'property-features-points'];
            } else {
                console.warn('initializePropertyFeatures not available from properties.js');
            }
        }

        // REMOVED: Custom displayPropertyFeatures function
        // Now using the standard displayFeaturesOnMap from properties.js instead
        function loadPropertyProfiles(propertyId) {
            $.get('/bucktrax/api/properties/' + propertyId + '/profiles')
                .done(function(profiles) {
                    displayProfiles(profiles);
                })
                .fail(function() {
                    window.App?.showModal?.("Error", "Failed to load profiles for this property.", "error");
                });
        }

        function displayProfiles(profiles) {
            const container = $('#profile-selector');
            container.empty();

            if (profiles.length === 0) {
                container.html(`
                    <div class="alert alert-success" style="background-color: #f0f8f0; border-color: #527A52; color: #2d3748;">
                        <i class="fas fa-info-circle me-2"></i>
                        No profiles found for this property. <a href="/properties/${selectedPropertyId}">Create a profile</a> to get started.
                    </div>
                `);
                return;
            }

            profiles.forEach(profile => {
                const statusBadge = getProfileStatusBadge(profile.profileStatus);
                const photoHtml = profile.coverPhotoUrl 
                    ? '<img src="' + profile.coverPhotoUrl + '" class="rounded me-2" style="width: 32px; height: 32px; object-fit: cover;">'
                    : `<div class="bg-secondary rounded me-2 d-flex align-items-center justify-content-center" style="width: 32px; height: 32px;"><i class="fas fa-deer text-white" style="font-size: 14px;"></i></div>`;

                const profileCard = $(`
                    <div class="card profile-item mb-2 cursor-pointer" data-profile-id="${profile.id}" style="cursor: pointer;">
                        <div class="card-body py-2">
                            <div class="d-flex align-items-center">
                                ${photoHtml}
                                <div class="flex-grow-1">
                                    <div class="fw-bold">${profile.name}</div>
                                    <div class="d-flex align-items-center">
                                        ${statusBadge}
                                        <small class="text-muted ms-2">${profile.tagName}</small>
                                    </div>
                                </div>
                                <i class="fas fa-chevron-right text-muted"></i>
                            </div>
                        </div>
                    </div>
                `);

                profileCard.on('click', function() {
                    selectProfile(profile.id, profile.name);
                });

                container.append(profileCard);
            });
        }

        function getProfileStatusBadge(status) {
            switch(status) {
                case 1: return '<span class="badge bg-success">Watching</span>';
                case 2: return '<span class="badge bg-warning">Hit List</span>';
                case 3: return '<span class="badge bg-dark">Harvested</span>';
                default: return '<span class="badge bg-secondary">Unknown</span>';
            }
        }

        function selectProfile(profileId, profileName) {
            selectedProfileId = profileId;
            
            // Update UI to show selection
            $('.profile-item').removeClass('border-primary');
            $('.profile-item[data-profile-id="' + profileId + '"]').addClass('border-primary');
            
            // Enable prediction button
            $('#run-prediction').prop('disabled', false);
            showPredictionSection();
        }

        function runMovementPrediction(profileId) {
            const button = $('#run-prediction');
            const loading = $('#prediction-loading');
            
            button.prop('disabled', true);
            loading.show();

            $.ajax({
                url: '/bucktrax/api/predict',
                method: 'POST',
                contentType: 'application/json',
                data: JSON.stringify({ 
                    profileId: profileId,
                    season: null,
                    timeOfDayFilter: null
                }),
                success: function(predictions) {
                    currentPredictions = predictions;
                    displayPredictionResults(predictions);
                    loading.hide();
                    button.prop('disabled', false);
                },
                error: function(xhr) {
                    loading.hide();
                    button.prop('disabled', false);
                    window.App?.showModal?.("Error", "Failed to generate movement predictions: " + (xhr.responseText || "Unknown error"), "error");
                }
            });
        }

        function displayPredictionResults(predictions) {
            // Show limited data warning if needed
            if (predictions.isLimitedData && predictions.limitedDataMessage) {
                $('#limited-data-message').text(predictions.limitedDataMessage);
                $('#limited-data-warning').show();
            } else {
                $('#limited-data-warning').hide();
            }

            // Update summary stats
            $('#total-sightings').text(predictions.totalSightings);
            $('#total-transitions').text(predictions.totalTransitions);
            $('#active-periods').text(predictions.timeSegments.filter(t => t.sightingCount > 0).length);

            // Initialize map (clear existing layers) BEFORE creating time segment tabs
            updateMapWithPredictions(predictions);
            
            // Create time segment tabs (this will populate the map with default segment data)
            createTimeSegmentTabs(predictions.timeSegments);

            // Show results section
            showResultsSection();
        }

        function createTimeSegmentTabs(timeSegments) {
            const tabsContainer = $('#time-segment-tabs');
            tabsContainer.empty();

            // Use defaultTimeSegmentIndex from predictions if available
            const defaultIndex = currentPredictions?.defaultTimeSegmentIndex ?? 0;

            timeSegments.forEach((segment, index) => {
                const isActive = index === defaultIndex ? 'active' : '';
                const badgeClass = segment.sightingCount > 0 ? 'bg-success' : 'bg-secondary';
                
                const tab = $(`
                    <li class="nav-item" role="presentation">
                        <button class="nav-link ${isActive} py-1 px-2" id="tab-${index}" data-bs-toggle="pill" data-bs-target="#content-${index}" type="button" role="tab">
                            <small>${segment.timeSegment.split(' ')[0]}</small>
                            <span class="badge ${badgeClass} ms-1">${segment.sightingCount}</span>
                        </button>
                    </li>
                `);
                
                tabsContainer.append(tab);
            });

            // Handle tab clicks
            tabsContainer.find('button').on('click', function() {
                const index = parseInt($(this).attr('id').split('-')[1]);
                displayTimeSegmentContent(timeSegments[index]);
                // Update map to show only the selected time segment's data
                updateMapForTimeSegment(timeSegments[index]);
            });

            // Show default segment (most active or earliest daylight)
            if (timeSegments.length > 0) {
                const selectedSegment = timeSegments[defaultIndex];
                displayTimeSegmentContent(selectedSegment);
                // Initialize map with the default segment's data
                updateMapForTimeSegment(selectedSegment);
            }
        }

        function displayTimeSegmentContent(segment) {
            const container = $('#time-segment-content');
            
            if (segment.sightingCount === 0 && (!segment.timeSegmentCorridors || segment.timeSegmentCorridors.length === 0)) {
                container.html(`
                    <div class="text-center text-muted py-3">
                        <i class="fas fa-eye-slash fa-2x mb-2"></i>
                        <div class="fw-bold">No Activity</div>
                        <small>No sightings during ${segment.timeSegment.toLowerCase()}</small>
                    </div>
                `);
                return;
            }

            let content = `
                <div class="mb-3">
                    <div class="fw-bold">${segment.timeSegment} (${formatTimeRange(segment.startHour, segment.endHour)})</div>
                    <div class="text-muted">Confidence: ${segment.confidenceScore}%</div>
                </div>
            `;

            if (segment.predictedZones && segment.predictedZones.length > 0) {
                content += `
                    <div class="mb-3">
                        <div class="fw-bold mb-2">Predicted Locations</div>
                        ${segment.predictedZones.slice(0, 3).map(zone => `
                            <div class="d-flex justify-content-between align-items-center mb-1">
                                <div>
                                    <div class="fw-bold">${zone.locationName}</div>
                                    <small class="text-muted">${zone.sightingCount} sightings</small>
                                </div>
                                <span class="badge badge-custom-primary">${Math.round(zone.probability * 100)}%</span>
                            </div>
                        `).join('')}
                    </div>
                `;
            }

            if (segment.timeSegmentCorridors && segment.timeSegmentCorridors.length > 0) {
                content += `
                    <div class="mb-3">
                        <div class="fw-bold mb-2">Movement Corridors</div>
                        ${segment.timeSegmentCorridors.slice(0, 2).map(corridor => `
                            <div class="d-flex justify-content-between align-items-center mb-1">
                                <div>
                                    <div class="fw-bold">${corridor.startFeatureName} → ${corridor.endFeatureName}</div>
                                    <small class="text-muted">${corridor.transitionCount} transitions</small>
                                </div>
                                <span class="badge bg-success">${corridor.corridorScore.toFixed(1)}</span>
                            </div>
                        `).join('')}
                    </div>
                `;
            }

            container.html(content);
        }

        function updateMapWithPredictions(predictions) {
            const map = window.App?.getMap?.();
            if (!map) {
                console.warn('Main map not available');
                return;
            }

            // Clear existing BuckTrax layers
            clearMapLayers();
            
            // Note: We don't add any data here anymore - 
            // the time segment selection will handle displaying the appropriate data
            // This function now just ensures the map is ready for time segment updates
        }

        function updateMapForTimeSegment(selectedSegment) {
            const map = window.App?.getMap?.();
            if (!map || !currentPredictions) {
                console.warn('Main map or predictions not available');
                return;
            }

            // Clear existing BuckTrax layers
            clearMapLayers();

            // Filter corridors to only show those for the selected time segment
            if (selectedSegment.timeSegmentCorridors && selectedSegment.timeSegmentCorridors.length > 0) {
                addCorridorsToMap(map, selectedSegment.timeSegmentCorridors);
            }

            // Add prediction zones for the selected time segment only
            if (selectedSegment.predictedZones && selectedSegment.predictedZones.length > 0) {
                addZonesToMap(map, selectedSegment.predictedZones);
            }

            // Fit map to show the selected segment's predictions
            fitMapToTimeSegment(map, selectedSegment);
        }

        function fitMapToTimeSegment(map, segment) {
            const bounds = new mapboxgl.LngLatBounds();
            let hasPoints = false;

            // Add corridor points to bounds
            if (segment.timeSegmentCorridors) {
                segment.timeSegmentCorridors.forEach(corridor => {
                    bounds.extend([corridor.startLongitude, corridor.startLatitude]);
                    bounds.extend([corridor.endLongitude, corridor.endLatitude]);
                    hasPoints = true;
                });
            }

            // Add zone points to bounds
            if (segment.predictedZones) {
                segment.predictedZones.forEach(zone => {
                    bounds.extend([zone.longitude, zone.latitude]);
                    hasPoints = true;
                });
            }

            // Only fit bounds if we have points
            if (hasPoints) {
                try {
                    map.fitBounds(bounds, { 
                        padding: 50,
                        maxZoom: 15 // Don't zoom in too close
                    });
                } catch (e) {
                    console.warn('Error fitting map bounds:', e);
                }
            }
        }

        function addCorridorsToMap(map, corridors) {
            const showCorridors = $('#show-movement-corridors').is(':checked');
            
            // Separate simple corridors from multi-point routes
            const simpleCorridors = corridors.filter(c => !c.isPartOfMultiPointRoute);
            const multiPointRoutes = corridors.filter(c => c.isPartOfMultiPointRoute);
            
            // Add simple corridors as lines
            if (simpleCorridors.length > 0) {
                addSimpleCorridors(map, simpleCorridors, showCorridors);
            }
            
            // Add multi-point routes with numbered indicators
            if (multiPointRoutes.length > 0) {
                addMultiPointRoutes(map, multiPointRoutes, showCorridors);
            }
        }

        function addSimpleCorridors(map, corridors, showCorridors) {
            const features = corridors.map(corridor => ({
                type: 'Feature',
                properties: {
                    name: corridor.name,
                    score: corridor.corridorScore,
                    transitions: corridor.transitionCount,
                    routeId: corridor.routeId,
                    isMultiPoint: false
                },
                geometry: {
                    type: 'LineString',
                    coordinates: [
                        [corridor.startLongitude, corridor.startLatitude],
                        [corridor.endLongitude, corridor.endLatitude]
                    ]
                }
            }));

            const sourceId = 'bucktrax-corridors-simple';
            const layerId = 'bucktrax-corridors-simple-lines';

            map.addSource(sourceId, {
                type: 'geojson',
                data: { type: 'FeatureCollection', features: features }
            });

            map.addLayer({
                id: layerId,
                type: 'line',
                source: sourceId,
                layout: { 
                    'line-join': 'round', 
                    'line-cap': 'round',
                    'visibility': showCorridors ? 'visible' : 'none'
                },
                paint: {
                    'line-color': '#00aa00',
                    'line-width': ['interpolate', ['linear'], ['get', 'score'], 0, 2, 10, 6],
                    'line-opacity': 0.8
                }
            });

            bucktraxLayers.corridors.push(layerId);
            bucktraxLayers.sources.push(sourceId);

            // Add click handler for simple corridors
            map.on('click', layerId, (e) => {
                const props = e.features[0].properties;
                new mapboxgl.Popup()
                    .setLngLat(e.lngLat)
                    .setHTML(`
                        <div class="p-2">
                            <div class="fw-bold">${props.name}</div>
                            <div>Score: ${props.score}</div>
                            <div>Transitions: ${props.transitions}</div>
                        </div>
                    `)
                    .addTo(map);
            });

            map.on('mouseenter', layerId, () => map.getCanvas().style.cursor = 'pointer');
            map.on('mouseleave', layerId, () => map.getCanvas().style.cursor = '');
        }

        function addMultiPointRoutes(map, routes, showCorridors) {
            routes.forEach((route, routeIndex) => {
                // Create line segments for the route
                const lineFeatures = [];
                for (let i = 0; i < route.routePoints.length - 1; i++) {
                    const current = route.routePoints[i];
                    const next = route.routePoints[i + 1];
                    
                    lineFeatures.push({
                        type: 'Feature',
                        properties: {
                            name: route.name,
                            score: route.corridorScore,
                            transitions: route.transitionCount,
                            routeId: route.routeId,
                            isMultiPoint: true,
                            segmentIndex: i
                        },
                        geometry: {
                            type: 'LineString',
                            coordinates: [
                                [current.longitude, current.latitude],
                                [next.longitude, next.latitude]
                            ]
                        }
                    });
                }

                // Add route lines
                const lineSourceId = `bucktrax-route-${routeIndex}-lines`;
                const lineLayerId = `bucktrax-route-${routeIndex}-lines-layer`;

                map.addSource(lineSourceId, {
                    type: 'geojson',
                    data: { type: 'FeatureCollection', features: lineFeatures }
                });

                map.addLayer({
                    id: lineLayerId,
                    type: 'line',
                    source: lineSourceId,
                    layout: { 
                        'line-join': 'round', 
                        'line-cap': 'round',
                        'visibility': showCorridors ? 'visible' : 'none'
                    },
                    paint: {
                        'line-color': '#ff6600', // Orange for multi-point routes
                        'line-width': ['interpolate', ['linear'], ['get', 'score'], 0, 3, 10, 8],
                        'line-opacity': 0.9
                    }
                });

                bucktraxLayers.corridors.push(lineLayerId);
                bucktraxLayers.sources.push(lineSourceId);

                // Add numbered point markers
                const pointFeatures = route.routePoints.map(point => ({
                    type: 'Feature',
                    properties: {
                        order: point.order,
                        name: point.locationName,
                        type: point.locationType,
                        visitTime: point.visitTime,
                        routeName: route.name,
                        routeId: route.routeId
                    },
                    geometry: {
                        type: 'Point',
                        coordinates: [point.longitude, point.latitude]
                    }
                }));

                const pointSourceId = `bucktrax-route-${routeIndex}-points`;
                const pointLayerId = `bucktrax-route-${routeIndex}-points-layer`;

                map.addSource(pointSourceId, {
                    type: 'geojson',
                    data: { type: 'FeatureCollection', features: pointFeatures }
                });

                map.addLayer({
                    id: pointLayerId,
                    type: 'circle',
                    source: pointSourceId,
                    layout: {
                        'visibility': showCorridors ? 'visible' : 'none'
                    },
                    paint: {
                        'circle-radius': 10,
                        'circle-color': [
                            'case',
                            ['==', ['get', 'order'], 1], 'rgba(0, 170, 0, 0.7)', // Start point: Green with embedded opacity
                            ['==', ['get', 'order'], route.routePoints.length], 'rgba(255, 68, 68, 0.7)', // End point: Red with embedded opacity
                            'rgba(255, 165, 0, 0.7)' // Mid points: Orange with embedded opacity
                        ],
                        'circle-stroke-width': 1.5,
                        'circle-stroke-color': '#ffffff',
                        'circle-stroke-opacity': 0.9
                    }
                });

                // Add number labels
                const labelLayerId = `bucktrax-route-${routeIndex}-labels-layer`;
                map.addLayer({
                    id: labelLayerId,
                    type: 'symbol',
                    source: pointSourceId,
                    layout: {
                        'text-field': ['get', 'order'],
                        'text-font': ['Open Sans Bold', 'Arial Unicode MS Bold'],
                        'text-size': 12,
                        'text-anchor': 'center',
                        'visibility': showCorridors ? 'visible' : 'none'
                    },
                    paint: {
                        'text-color': '#ffffff'
                    }
                });

                bucktraxLayers.corridors.push(pointLayerId, labelLayerId);
                bucktraxLayers.sources.push(pointSourceId);

                // Add click handlers for route lines
                map.on('click', lineLayerId, (e) => {
                    const props = e.features[0].properties;
                    new mapboxgl.Popup()
                        .setLngLat(e.lngLat)
                        .setHTML(`
                            <div class="p-2">
                                <div class="fw-bold">${props.name}</div>
                                <div class="text-info">Multi-point Route</div>
                                <div>Score: ${props.score}</div>
                                <div>Transitions: ${props.transitions}</div>
                            </div>
                        `)
                        .addTo(map);
                });

                // Add click handlers for route points
                map.on('click', pointLayerId, (e) => {
                    const props = e.features[0].properties;
                    const visitTime = new Date(props.visitTime).toLocaleString();
                    new mapboxgl.Popup()
                        .setLngLat(e.lngLat)
                        .setHTML(`
                            <div class="p-2">
                                <div class="fw-bold">Stop ${props.order}: ${props.name}</div>
                                <div class="text-muted">${props.type}</div>
                                <div><small>Visited: ${visitTime}</small></div>
                                <div class="text-info"><small>Route: ${props.routeName}</small></div>
                            </div>
                        `)
                        .addTo(map);
                });

                // Add hover effects
                map.on('mouseenter', lineLayerId, () => map.getCanvas().style.cursor = 'pointer');
                map.on('mouseleave', lineLayerId, () => map.getCanvas().style.cursor = '');
                map.on('mouseenter', pointLayerId, () => map.getCanvas().style.cursor = 'pointer');
                map.on('mouseleave', pointLayerId, () => map.getCanvas().style.cursor = '');
            });
        }

        function addZonesToMap(map, zones) {
            const features = zones.map(zone => ({
                type: 'Feature',
                properties: {
                    name: zone.locationName,
                    probability: zone.probability,
                    sightings: zone.sightingCount,
                    isCorridor: zone.isCorridorPrediction
                },
                geometry: {
                    type: 'Point',
                    coordinates: [zone.longitude, zone.latitude]
                }
            }));

            const sourceId = 'bucktrax-zones';
            const layerId = 'bucktrax-zones-circles';

            map.addSource(sourceId, {
                type: 'geojson',
                data: { type: 'FeatureCollection', features: features }
            });

            // Check initial visibility state
            const showZones = $('#show-prediction-zones').is(':checked');

            map.addLayer({
                id: layerId,
                type: 'circle',
                source: sourceId,
                layout: {
                    'visibility': showZones ? 'visible' : 'none'
                },
                paint: {
                    'circle-radius': ['interpolate', ['linear'], ['get', 'probability'], 0, 8, 1, 20],
                    'circle-color': [
                        'case',
                        ['get', 'isCorridor'],
                        'rgba(255, 165, 0, 0.7)', // Orange for corridor predictions with embedded opacity
                        'rgba(255, 68, 68, 0.7)'  // Red for sighting zones with embedded opacity
                    ],
                    'circle-stroke-width': 2,
                    'circle-stroke-color': '#ffffff',
                    'circle-stroke-opacity': 0.9
                }
            });

            bucktraxLayers.zones.push(layerId);
            bucktraxLayers.sources.push(sourceId);

            // Add click handler
            map.on('click', layerId, (e) => {
                const props = e.features[0].properties;
                new mapboxgl.Popup()
                    .setLngLat(e.lngLat)
                    .setHTML(`
                        <div class="p-2">
                            <div class="fw-bold">${props.name}</div>
                            <div>Probability: ${Math.round(props.probability * 100)}%</div>
                            <div>Sightings: ${props.sightings}</div>
                        </div>
                    `)
                    .addTo(map);
            });

            map.on('mouseenter', layerId, () => map.getCanvas().style.cursor = 'pointer');
            map.on('mouseleave', layerId, () => map.getCanvas().style.cursor = '');
        }

        function fitMapToPredictions(map, predictions) {
            const bounds = new mapboxgl.LngLatBounds();
            let hasPoints = false;

            // TEMPORARILY DISABLED: Add corridor points to bounds
            // TODO: Re-enable when corridor visualization is ready
            // predictions.movementCorridors.forEach(corridor => {
            //     bounds.extend([corridor.startLongitude, corridor.startLatitude]);
            //     bounds.extend([corridor.endLongitude, corridor.endLatitude]);
            //     hasPoints = true;
            // });

            // Add zone points to bounds
            predictions.timeSegments.forEach(segment => {
                segment.predictedZones.forEach(zone => {
                    bounds.extend([zone.longitude, zone.latitude]);
                    hasPoints = true;
                });
            });

            if (hasPoints && !bounds.isEmpty()) {
                map.fitBounds(bounds, { padding: 50, maxZoom: 16 });
            }
        }

        function clearMapLayers() {
            const map = window.App?.getMap?.();
            if (!map) return;

            // Remove only BuckTrax-specific layers (corridors and zones), NOT property features
            [...bucktraxLayers.corridors, ...bucktraxLayers.zones].forEach(layerId => {
                if (map.getLayer(layerId)) {
                    try {
                        map.removeLayer(layerId);
                    } catch (e) {
                        console.warn('Error removing layer:', layerId, e);
                    }
                }
            });

            bucktraxLayers.sources.forEach(sourceId => {
                if (map.getSource(sourceId)) {
                    try {
                        map.removeSource(sourceId);
                    } catch (e) {
                        console.warn('Error removing source:', sourceId, e);
                    }
                }
            });

            // Clear tracking arrays for BuckTrax layers only (keep features)
            bucktraxLayers.corridors = [];
            bucktraxLayers.zones = [];
            bucktraxLayers.sources = [];
            // Note: bucktraxLayers.features is NOT cleared - property features should remain
        }

        function clearFeatureLayers() {
            const map = window.App?.getMap?.();
            if (!map) return;

            // Only clear property features when switching properties
            bucktraxLayers.features.forEach(layerId => {
                if (map.getLayer(layerId)) {
                    try {
                        map.removeLayer(layerId);
                    } catch (e) {
                        console.warn('Error removing feature layer:', layerId, e);
                    }
                }
            });

            // Also remove the property-features source managed by properties.js
            if (map.getSource('property-features')) {
                try {
                    map.removeSource('property-features');
                } catch (e) {
                    console.warn('Error removing property-features source:', e);
                }
            }

            bucktraxLayers.features = [];
        }

        function updateLayerVisibility() {
            const map = window.App?.getMap?.();
            if (!map) return;

            const showCorridors = $('#show-movement-corridors').is(':checked');
            const showZones = $('#show-prediction-zones').is(':checked');
            const showFeatures = $('#show-property-features').is(':checked');
            const showCameras = $('#show-cameras').is(':checked');

            // Corridor layer visibility
            bucktraxLayers.corridors.forEach(layerId => {
                if (map.getLayer(layerId)) {
                    map.setLayoutProperty(layerId, 'visibility', showCorridors ? 'visible' : 'none');
                }
            });

            bucktraxLayers.zones.forEach(layerId => {
                if (map.getLayer(layerId)) {
                    map.setLayoutProperty(layerId, 'visibility', showZones ? 'visible' : 'none');
                }
            });

            bucktraxLayers.features.forEach(layerId => {
                if (map.getLayer(layerId)) {
                    map.setLayoutProperty(layerId, 'visibility', showFeatures ? 'visible' : 'none');
                }
            });

            // Camera marker visibility
            if (window.App._cameraMarkers) {
                window.App._cameraMarkers.forEach(marker => {
                    if (showCameras) {
                        marker.addTo(map);
                    } else {
                        marker.remove();
                    }
                });
            }
        }

        function formatTimeRange(start, end) {
            const formatHour = (hour) => {
                // Normalize hour to 0-23 range (handle 24 as 0)
                hour = hour % 24;
                if (hour === 0) return '12:00 AM';
                if (hour === 12) return '12:00 PM';
                if (hour < 12) return hour + ':00 AM';
                return (hour - 12) + ':00 PM';
            };

            if (start <= end) {
                // Normal case: same day (e.g., 9:00 AM - 5:00 PM)
                return formatHour(start) + ' - ' + formatHour(end);
            } else {
                // Cross-midnight case: start is PM, end is AM next day (e.g., 8:00 PM - 6:00 AM)
                return formatHour(start) + ' - ' + formatHour(end) + ' (+1 day)';
            }
        }

        // UI Helper Functions
        function showProfileSection() { $('#profile-section').show(); }
        function hideProfileSection() { 
            $('#profile-section').hide(); 
            hidePredictionSection();
        }
        function showPredictionSection() { $('#prediction-section').show(); }
        function hidePredictionSection() { 
            $('#prediction-section').hide(); 
            hideResultsSection();
        }
        function showResultsSection() { $('#results-section').show(); }
        function hideResultsSection() { 
            $('#results-section').hide(); 
            clearMapLayers();
        }

        function clearAllLayers() {
            const map = window.App?.getMap?.();
            if (!map) return;

            // Remove ALL layers (both BuckTrax and property features) - used for cleanup
            [...bucktraxLayers.corridors, ...bucktraxLayers.zones, ...bucktraxLayers.features].forEach(layerId => {
                if (map.getLayer(layerId)) {
                    try {
                        map.removeLayer(layerId);
                    } catch (e) {
                        console.warn('Error removing layer:', layerId, e);
                    }
                }
            });

            bucktraxLayers.sources.forEach(sourceId => {
                if (map.getSource(sourceId)) {
                    try {
                        map.removeSource(sourceId);
                    } catch (e) {
                        console.warn('Error removing source:', sourceId, e);
                    }
                }
            });

            // Also remove the property-features source managed by properties.js
            if (map.getSource('property-features')) {
                try {
                    map.removeSource('property-features');
                } catch (e) {
                    console.warn('Error removing property-features source:', e);
                }
            }

            // Clear all tracking arrays
            bucktraxLayers.corridors = [];
            bucktraxLayers.zones = [];
            bucktraxLayers.features = [];
            bucktraxLayers.sources = [];
        }

        // Clean up when leaving the page
        $(window).on('beforeunload', function() {
            clearAllLayers();
        });
    </script>
}